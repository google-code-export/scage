СОВЕТИКИ
Нужно начать писать советики по разработке приложений под scage. Типа Best Practices. Постараюсь постепенно пополнять
список новыми советиками

* все action'ы, render'ы итд только в объектах, но не в классах.
--
Мм, спорно же... Ну, то есть, если внутри класса определены action'ы или еще что, значит там полюбас импортирован
соответствующий ScageScreen объект (ну или еще каким извращенным способом присутствует). Таким образом, этот класс
 все равно не удастся использовать в отрыве от объекта, как-то по-левому.. Или потенциальный баг в самом объекте, что
 он не сможет проследить за своевременным удалением action'а и такое сложно отследить... Ну хз.

* все var с модификаторами только private
--
Не актуально, за нас уже подумали. ОКАЗЫВАЕТСЯ, поля в классах всегда имеют самый зверский модификатор private[this], и если
мы выставили для var публичный или протектед модификатор, автоматически генерятся геттер и сеттер. Это оче круто,
на самом деле. Примечательно, что во всем коде scage мне понадобилось всего в двух местах удалить лишние геттеры-сеттеры)

----------------
удаление клавиш

продумать:
* гарантии инициализации пропертей (проперти в виде трейта?)
* независимость рендера от пропертей (передача нужных вещей в виде параметров в функцию инициализации)
* независимость ScageMessage от пропертей
* логирование запуска юнитов
* трейты Renderer и ScageController получились неотделимы от Scage, отдельно их не получится использовать. Подумать, насколько
это плохо.

надо придумать и написать PerformanceTest

сделать профиль noscagelogo, и в нем собирать либу без логотипа Scage. По умолчанию собирать с логотипом. От
настройки scage.logo в Renderer избавиться.

всегда явно писать тип возвращаемого значения

проставить в нужных местах final и sealed

полностью делать интерфейс экранов в xml, как в андроиде. Продумать язык описания интерфейса.

перепилить функции-удалялки через няшное collections api

в трейсерах:
getState -> state
traces_in_point -> traces_points (done)

point_matrix -> изменить тип: Array[ArrayBuffer[T]]
--
не годится, придется делать toList в методах, отдающих куски из point_matrix (прям ArrayBuffer-то стремновато отдавать)

http://www.scala-lang.org/node/10473
По ссылке скакалочные изменения в версии 2.9.1
Это надо внимательно прочитать и по возможности впилить в scage, куда надо.

Например, паралелльные коллекции. Это ведь круто?

The App Trait, The DelayedInit Trait - вот мне очень хочется избавиться от обязательного def main(args:Array[String]) {run()}
в объекте-главном экране. В идеале это должно быть что-то такое, что мы пишем весь инициализированный код в нашем
клиенстком объекте, а при запуске, будет вызван он и потом run(). И еще надо чтобы учитывалось, что наследник
ScageScreen может не обязательно быть объектом и тогда чтобы в нем не было ни main, ничего такого.

New methods in collections:
collectFirst, maxBy, minBy, span, inits, tails, permutations, combinations, subsets


можно запилить в init нечто вроде проверки: после отработки всех init-функций мы подсчитываем количество экшонов,
рендеров и интерфейсов. Если количество чего-нибудь увеличилось с последнего запуска инит, отдаем ворнинг с
информацией, чего стало больше. По идее, повторные вызовы init означают перезапуск приложения, то есть по идее все
 в нем должно вернуться к исходному состоянию. Если чего-то стало больше - где-то прога не удаляет за собой, и это
 может привести к переполнению, тормозам итд.

Я прочитал в книжке про ковариантность и контравариантность, и теперь можно подумать, надо ли запиливать что-то
такое в трейсерах

Круто! Оказывается, текущая архитектура контроллера не позволяет добавлять несколько событий на одну клавишу, например,
как-нибудь так:
  key(KEY_1, onKeyDown = println("1!"))
  key(KEY_1, onKeyDown = println("one!"))
отработает только последнее!
С кнопками мыши и другими ее событиями ситуация немного отличается, но работает тоже нестабильно.
---
мб пойти в обратную сторону и запилить возможность на каждую кнопку клавиатуры/мыши, на мышиные
движения/перетаскивания и колесико вешать ровно одну функцию. Повторное добавление перезаписывает текущую

Сделать, чтобы окошко по центру экрана запускалось (done, хотя возможны траблы на мультимониторной системе)

Одноразовые самоудаляющиеся экшоны. Экшоны запускающиеся с задержкой (типа синтаксический сахар такой. И то и то сейчас
может быть реализовано средствами движка).
--
пока неактуально

Сделать объект-компаньон-фабрику для ScagePhysics. Пусть будет апи, похожее на те, что предоставляют объекты коллекций:
val physics = ScagePhysics(ball, floor, left_wall, right_wall, roof, table)
типа оно нам сделает physics и сразу туда добавит нужное. Подумать аналогично про трейсеры.

Доработать апи в ScagePhysics в части касающейся регистрации касаний-столкновений. Вроде phys2d умеет определять точку
касания, надо ее отдавать. Важно же знать не просто, что тела коснулись, а каким они местом коснулись (например,
ударились об стенку в процессе падения, или таки уже ебнулись об пол и пора умирать).

physicals в ScagePhysics - сделать ArrayList
--
или ArrayBuffer, а чо

Renderer: мб scale тоже сделать функцией?.. Подумать о производительности функций center() и window_center()
window_center() особо не используется, кажется он использовался в Blamer только..
Мб предусмотреть два режима: когда эти штуки - изменяемые переменные, и когда функции...
--
этак и backgroundColor и color можно запилить функциями... В общем, серьезно подумать о целесообразности
--
гыгы, нее, низя scale сделать функцией. Иначе будет обсираться более простой юзкейс:
key(KEY_ADD, onKeyDown = {scale += 1})
типа по нажатию на плюсик увеличить масштаб. Если scale будет функцией, то эта функция:
{scale + 1}
будет вызываться каждый такт, в результате после нажатия на плюс картинка начнет непрерывно приближаться.
Воркэраунд от этого выглядит более херово:
private var my_scale = 1
scale = my_scale
key(KEY_ADD, onKeyDown = {my_scale += 1})
три строчки вместо одной. Аналогичные возможные траблы с color и backgroundColor. С другой стороны, с текущим апи,
если нам надо, чтобы масштаб изменялся в зависимости от чего-то, мы пилим что-то такое (пример из проекта Uke):
action {
  scale = if(Uke.coord.y - fartherst_coord.y > screen_height/2) screen_height/2/(Uke.coord.y - fartherst_coord.y) else 1
}
примерно такое же было бы написано, если scale - функция:
scale = {
  if(Uke.coord.y - fartherst_coord.y > screen_height/2) screen_height/2/(Uke.coord.y - fartherst_coord.y) else 1
}
как-то так, кароч

ScagePhysics: изменяемый dt (done)

GRAY и DARK_GRAY надо бы местами поменять (done)

подумать над усложнением схемы работы: предусмотреть возможность перезапуска. Изначально подразумевалось, что код в списке
exits будет вызываться только при окончании работы приложения. Но конечно же суперудобно сделать возможность перезапуска
игры без выхода из приложения, тем более что это достигается практически нахаляву связкой exit(); init();
Проблема в том, что в exits может содержаться код, освобождающий ресурсы насовсем, так что последующие init() и run() обосрутся.
Конечно, не до конца понятно, нужен ли такой код под ява-машиной, все равно, при выходе jvm освободит все...
Вощем как вариант можно запилить еще один список функций, только название для него пока не придумал

Вообще кастомиазция процесса старта приложения и его завершения - отдельная тема, но пока не актуальная. Пока:
слово Loading..., потом логотип движка, потом логотип игры, если есть или вступительная фраза (имя разработчика например),
дальше собственно игра. Показ логотипов и фраз все по 1 секунде, фразы пишутся слева сверху зеленым цветом главным шрифтом.
После игры - слово Exiting...

апгрейд парсилки xml:
пусть принимает еще произвольные аттрибуты, например цвет сообщения, позиция, пауза перед выводом итд. Пусть функция xml()
возвращает json со всеми этими данными и из него уже можно будет нужно вытаскивать

написать функция color:String -> ScageColor (done)

настройка id.start не нужна, потому что нет никакого смысла ее менять, и даже сейчас к этому есть препятствия:
она должна быть не меньше 10000. Пусть она просто будет 10000  (done)

drawRect и drawFilledRect принимают координату и считает ее центральной! Надо еще чтобы был левый верхний угол, как обычно. (done)
--
старые функции переименованы с добавлением префикса Centered. Обратную совместимость я в гробу видал, притом что проектов
все равно никаких нет пока :3

баг с отрисовкой физических полигонов закрашенными мнгоугольниками (функция drawFilledPolygon)

action'ы, которые не тормозятся паузой. Сейчас есть настройка pause.global: если она true, все экшены останавливаются   (done)
на паузе, если false - никакие не останавливаются, и можно там дальше в коде нужных экшонов предусмотреть, влияет ли на
исполнение пауза или нет. Мб вынести эту логику на уровень движка, чтобы были actionNoPause и обычные. Тогда можно
настройку pause.global выкинуть.
--
Аналогично можно предусмотреть влияние паузы на рендеры и на нажатие клавиш.

drawPolygon не имеет параметра color, ай-я-яй (done)
--
орлы? тащем-та просто не было метода, принимающего List в качестве аргумента. Аналогично допилил для drawFilledPolygon

принудительный показ ололологотипа движка (done)

аналогично drawPoints - drawLines (done)

написать апи для проигрывания анимации
--
надо сначала подумать, как бы такое апи могло выглядеть. Хотя можно, как я обычно делаю: написать под определенные нужды,
и если в следующем приложении написанного не хватат, допиливать под него итд.
--
предварительно соснул хуйцов. предложенный вариант апи менее гибкий, чем текущий, через переменную current_frame,
один экшон и один рендер. Надо этот юзкейс как-то весь годно формализовать в один периодический метод.

мелкие оптимизации:
метод removeTrace/removeTraceById (один типа, чтобы не было лишнего foreach), итд
--
тогда и для экшонов что ли такое пилить? я ебанусь же.

подумать на досуге о возможности переполнения айдишников и возможном замедлении работы при логировании
их генерации (в режиме дебаг, при добавлении новых трейсов, например)

начать ботать Java Web Start. В перспективе это должно стать профилем в pom.xml (done)
--
крутота!

новый метод в трейсере: removeTraceByPoint/removeTraceByCoord
--
необходимость пока под вопросом

сообщение в логе при постановке/снятии с паузы (done)
--
нужно например за тем, чтобы иметь возможность все же отслеживать состояние "на паузе/не на паузе", даже
если в интерфейсе это нигде не отображается никак (клиентский разработчик может в программе нигде не помечать состояние паузы)

outsidePoint(...) -> point(...)
--
нее: метод point из CoordTracer перенести в ScageTracer (done)

мб переписать методы типа drawPolygon итд, принимающие произвольное количество координат: сначала цвет,
потом координаты. Это избавит от дополнительного метода (вроде)

допилить drawPoint чтобы принимал список точек (done)
--
метод drawPoints


В ScageMessage добавить методы принимающие Vec вместо float, float
--
дописать в ScageMessage методы print*, принимающие Vec

сделать клавишу "any key" =) (done)

Возможность задания периодичности работы action'ов by-value значением, то есть возможность менять ее на ходу  (done)
--
Сделано. Оставлен предыдущий вариант - статичный период между выполнением action'ов: actionWithStaticPeriod
Благодаря опциям компилятора он даже может быть немножко оптимизированный..)

Возможность передавать State в событийном фреймворке в ScageScreen
--
снабдить логами событийный фреймворк

мб все настройки, начальные параметры вывести в *.properties. Тогда все можно переписать трейтами..
--
тогда будут траблы, если например в клиентском приложении требуется два трейсера в одном классе итд
и вообще, трейт - это если все-таки нужны какие то абстрактные методы

trait ScageTracer
--
фейл. Нельзя иметь одноименные trait и класс. Так что уж лучше класс

Trace extends State
просто и гениально :3
--
свои подводны камни тут тоже есть. Вызов getState начитывал каждый раз в State нужные параметры, и таким образом их
актуальность гарантировалась. Сейчас ничего такого не гарантируется. Более того, любой может сделать любой put в trace!
--
Полный фейл. Устранение подводных камней чересчур усложняет код движка. Откатываюсь назад

pointMatrix --> createMatrix   (done)
--
удалил совсем
--
запилил initMatrix

продумать еще раз добавление action от условий:
условие выполнения action, или период между выполнениями, условие удаления. события при удалении... (done)
--
реализовал просто период между выполнениями, но он может динамически меняться

----------------

RoadMap
v0.5
* physics перенести в support, сделать по аналогии с tracer. До меня внезапно дошло, что в чем-то эти две
структуры весьма схожи. (done)
* переименовать --> в более простое addPhysical (done)
* newtracer перенести в tracer, tracer удалить (done)
* Переименовать базовый класс Tracer в ScageTracer (done)
* В tracer в функции traces добавить отдельные аргументы rangex и rangey (вместо общего range по обоим осям
сейчас) (done)
* Также добавить функцию, возвращающую объекты только с заданной точки (done)
* Поправить баг в updateLocation - если trace.id не был добавлен и не существует в traces_in_coord (done)
* В Renderer в методы draw* добавить аргумент _color, равный по умолчанию текущему цвету. (done)
* добавить функционал по вводу строк (отдельное окошко на свинге с простым текстовым полем, ввод по ctrl-enter)
* Добавить метод, рисующий точку (хочу себе навороченный бейсик)) (done)
* сообщения в логах при удалении операций из ScageScreen (done)

----------------

В движке есть следующие компоненты:
ScageScreen
Controller + Renderer + ScageColors + Keyboard + Mouse
ScageProperties
ScageMessages
NetServer + NetClient
Tracer
ScagePhysics
Постараться, чтобы они не зависили друг от друга, чтобы каждый из этих комопнентов можно было использовать отдельно от
движка.
--
мб допилить, чтобы можно было все параметры задавать как параметры (некоторые сейчас можно только через
файл .properties)

есть operation_id - для скринов и рендеров, есть trace_id - для трейсов и есть disaplylist_key - для дисплейных списков.
последний начинается с 10000 в качестве воркэраунда для одного шняги. Код практически одинаковый.
Мб сделать единый счетчик для всего вообще.              (done)
--
и перефигачить в Long
--
сделано. Long не удалось из-за дисплейных списокв

main screen - сделать единственным в системе, или оставить текущее положение? Вариант ТЗ:
при создании объекта ScageScreen в качестве параметра передавать имя. Первый созданный скрин станет main, для него
будут начитаны переданные проперти. Если проперти не переданы, пытаемся прочитать файл "имя скрина".toLower+".properties"
Главный скрин сейчас по сути - если для него вызвать stop, закрывать программу полностью. В принципе можно сделать программу
без мейн скрина (все скрины - не мейн), и программу с несколькими мейнами. Только смысл? Аналогично с пропертями: можно
переначитывать разные файлы несколько раз в программе в зависимости от. Другое дело, что это можно сделать и безотносительно
к системе скринов..
В общем, первый запущенный скрин становится мейном. Мейн в приложении может быть только один. Если мейн закрылся, приложение
в целом тоже. Относительно мейна начитываются проперти
--
переусложнения и ненужные ограничения, пока отказался

система эвентов в ScageScreen: onEvent(HERO_DIES) {...}, callEvent(HERO_DIES) итд     (done)
--
реализовал, но пока так и не придумал, где это применить. Коды эвентов - строковые константы

удалять рендеры (мб и контролы)      (partly-done)
--
сделал удаление рендеров. про контролы пока непонятно, нужно ли

su.msk.dunno -> net.eredory

продумать:
  * поставку в виде web start
  * поставку в виде апплета
  * продумать сетевой режим через интернет

В общем, мб все отдельные сущности поставлять в двух видах: синглтонами и классами
Например, ScageMessages - классом, чтобы можно было в одном приложении юзать разные шрифты разных размеров итд

Также мб сделать реализации некоторых вещей сразу встроенными в скрины (типа ФизиксСкрин, НетСкрин)
Возможно, что-то можно сделать также трейтами, чтобы еще удобнее было собирать приложение как конструктор
из компонентов

сделать сетевые сущности синглтонами или классами?
  плюсы синглтонов: удобнее синтаксис, можно статически импортить содержимое NetServer/NetClient, и сразу писать
  предметный код, не создавая никаких объектов. Также, более чистенько выглядит взаимодействие
  NetServer - ClientHandler (не надо соображать, выносить ли порт, макс_клиентс, и чек_таймаут в отдельный
  объект, начитывать из файла, или задавать параметром для каждого класса НетСервер и передавать
  клиентхэндлеру нужный ему чек_таймаут...)

  плюсы классов: шире возможности. Можно создавать много разных серверов и клиентов на разных портах и работать
  со всеми одновременно. Вопрос, нужно ли это. Ладно, если будет нужно, перепишу.

запилить режим работы без графики

сделать нормальный общий Logger, который принимает by-name параметры и делает проверку isDebugEnabled итд
--
подумать над вменяемым, красивым и производительным логированием
--
добавить в него возможность продолжать писать лог на той же строке

переименовать в Renderer: createDisplayList -> image, createAnimation -> animation (done)

Раз уж удаление операций вроде фурычит, мб придумать какой-нить механизм самоудаления операций... (done)
--
сделал метод currentOperaion в объекте ScageScreen - возвращает id текущей операции. Таким образом операция может
прочитать его и удалить, удалив таким образом себя

в ScageScreen добавить функции, принимающие списки айдишников операций и удаляющие соотв операции (done)

придумать dsl для парсинга State
--
Нужен более простой синтакисис работы с классом State. JSON-like стиль в целом хорош, но тоже может стать болью в
заднице, когда мы спускаемся на более низкие уровни вложенности. Кроме того нужно продумать задание правил и
зависимостей между значениями внутри State (возможно не в рамках Scage, возможно только в Blamer)

дописать в tracer методы, возвращающие случайные координаты (done)
--
добавить в randomPoint/randomCoord условие, по которому производить генерацию
--
подумал и решил, что это лишнее, потому что скорость работы этих функций более не будет гарантированной
лучше решать проблему отсеивания нужных случайных позиций средствами клиентского приложения (как в Snake)

дальнейший рефакторинг: избавиться от пакета single, перенеся все из него в support и еще куда надо. Пакет screens
cтановится единственным, и его можно поднять на уровень вверх - su.msk.dunno.scage

начать писать комментарии в формате javadoc

Мб объединить генерацию дисплейных списокв в UnicodeFont с генерацией в Renderer, для остальной части Scage
--
сложновато

еще раз продумать апи physics
--
Вообще, тут не надо думать, тут просто прогать надо, кучу разных проектов, где задействован физический движок. По мере
прояснения, что и где требуется и как применять, будет яснее и насчет ТЗ на апи.

доделать drawPolygon и drawFilledPolygon    (done)
--
не помню, что я там хотел доделать, но наверное доделал, пушо сейчас к этому апи претензий нет

Реализовать механизм ввода текстовой информации
--
окошко свинговое с текстовым полем

Переделать Tracer, чтобы сам вычислял где какой трейс лежит (хранил мап) (done)

Мб завести иерархию файлов строк, которые читает движок при запуске, или просто на этапе сборки мавеном начитывать в один
файл из умолчальных файлов и из application-specific.

Поправить взаимодействие Renderer со ScageScreen в случае, когда мы - main_screen (done)

Переделать цветные строки

Апдейт пропертей: возможность задавать цвета, а также векторные величины (из двух значений)
--
возможность задавать цвета сейчас реализована следующим образом: в ScageColors впилен метод, принимающий имя цвета
и отдающий цвет (задействована такая-то крутая рефлексия)

Мб все-таки хранить файлы resources внутри джарника программы, как все крутые пацаны делают (done)
--
аналогично мб проперти (done)
--
это адово необходимо, когда у нас webstart например

Надо разработать план по описанию движка Scage: словесное описание, примеры кода, готовые приложения разные, куча
картинок. Подробное описание способов быстрого создания нового проекта (через мавеновский архетип), сборки готового
приложения. Все это на русском, потом на английский перевести (как можно быстрее).

Добавить поддержку мышки в Controller (done)

возможность определять проперти через другие проперти
name = $app_name - $version

Надо продумать возможность перезапуска игры связкой exit - init, или просто init, чтобы можно было все грамотно
инициализировать - в частности, для физического движка чтобы все работало  (done)